#ifndef SC_GENERATION_H
#define SC_GENERATION_H

/** @file sc_generation.h
Classes for optical generation distribution
Documentation to the general structure of the code can be found at doc/tutorial.doxc
*/

#include "refobj.h"
#include "grid.h"
#include "math_utils.h"
#include "component.h"

// The header is needed just for the next typedef
#include "vector_3.h"
typedef vec_type valtype; // double or float (if macro SINGLE_PRECISION is defined)


// Base class to specify optical generation rate distribution
// operator () returns generation rate in photons/(sec m^3)
class scGeneration: public virt_unary_function<const Vector_3 &, vec_type>{
protected:
  valtype length_unit; // argument of operator () is measured in length_uinit, meters
public:
  scGeneration():length_unit(1e-6){}
  // lu in microns
  void SetLengthUnit(valtype lu){
    length_unit=lu*1e-6;
  }
  // reserved for inherited classes where generation depends on voltage (i. e. in photonic recycling algorithm)
  // returns 1 if generation depends on voltage
  virtual int change_voltage(valtype v){return 0;}
};

struct scGenerationRegion: public apComponent{
  mngptr<Region_3> reg; // region where it works
  mngptr<scGeneration> gen; // generation

  scGenerationRegion(mngarg<scGeneration> gen_, mngarg<Region_3> sreg): gen(gen_), reg(sreg){}
};

// Uniform optical generation rate (generate rate is constant)
class scGenerationUniform: public scGeneration{
  valtype gen; // generation rate in photons/(sec m^3)
public:
  scGenerationUniform(valtype gen_):gen(gen_){}
  valtype operator()(const Vector_3 &pos) {
    return gen;
  };
};

/* Optical generation rate is calculated using Lambert law:
I*alpha*exp(-alpha*x), 
where x is distance from semiconductor plane interface,
I is incident light intencity, alpha is absorption coefficient */
class scLambert: public scGeneration{
  Plane_3 pl; // semiconductor plane interface
  valtype I; // incident light intencity, photons/(sec m^2)
  /* absorption coefficient, m^-1
   could be expressed as 2*w*k/C = 4*PI/lambda*k, where
   C - speed of light
   w (in rad/sec) - light frequency, lambda - light wavelength
   k - imaginary part of refractive index */
  valtype alpha;
public:
  // I is light intencity, photons/(sec m^2)
  scLambert(Plane_3 pl_, valtype I_, valtype alpha_):pl(pl_),I(I_),alpha(alpha_){}
  // I is light intencity, J/(s m^2) = W/m^2, wv is light wavelength, nm
  // absorption coefficient expressed as 4*PI/lambda*k,
  // where refractive index k is taken from the tabular file dir/fabs in format 'wavelength - n - k'
  scLambert(Plane_3 pl_, valtype I_, valtype wv, const char *dir, const char *fabs);
  
  valtype operator()(const Vector_3 &pos) {
    valtype dist=pl.distance(pos)*length_unit;
    if(dist<0)
      return 0;
    valtype decay=exp(-alpha*dist);
    valtype val=I*alpha*decay;
    return val;
  }
};

// Optical generation rate is calculated using Lambert law for some incident spectrum
class scLambertSpectrum: public scGeneration{
  Plane_3 pl; // semiconductor plane interface
  valtype *I,*alpha; // Intensity and absorption coefficient spectral distribution
  valtype Imult; // multiplication coefficient for I (one by default)
  int num; // size of arrays I, alpha
public:

  /* dir - directory where files flight, fabs can be found
   flight is tabular file in format 'wavelength - I'
   fabs is tabular file in format 'wavelength - n - k' (the same as for scLambert constructor)
   incident spectrum is taken in [wv1, wv2] wavelength range */
  scLambertSpectrum(Plane_3 pl_, const char *dir, const char *flight, const char *fabs,
    valtype wv1, valtype wv2, valtype Imult_=1, const char *filter=NULL, int jfilter=0);

  ~scLambertSpectrum(){
    if(alpha)delete[]alpha;
    if(I)delete[]I;
  }

  valtype operator()(const Vector_3 &pos) {
    valtype dist=pl.distance(pos)*length_unit;
    if(dist<0)
      return 0;
    valtype val=0;
    for(int i=0;i<num;i++){
      valtype decay=exp(-alpha[i]*dist);
      val+=I[i]*alpha[i]*decay;
    }
    return val*Imult;
  }
};

// Generation rate [photons/(sec m^3)] stored at the rectangular mesh 
// It can be taken from some file generated by independent electromagnetic simulation
// Rectangular mesh can be shifted and linearly transformed from the simulated geometry
// (this is regulated by bs and shift)
class scGenerationTable: public scGeneration{
  valtype *gen; // generation data array
  // 3D rectangular grid which specifies spatial location of stored data
  // this grid is used to get interpolation coefficients and indices for arbitrary position
  UniformGrid<valtype> grd;
  Basis_3 bs; // linear transformation of the rectangular mesh relatively to the simulation geometry
  Vector_3 shift; // shift of the rectangular mesh relatively to the simulation geometry
  valtype Imult; // multiplication coefficient for I

  // ord - from slowest to fastest
  int pack(const int *N, const int *ord, const int *ic, int argnum);

public:

  scGenerationTable(): gen(), Imult(1){}

  /* only generation data [photons/(sec m^3)] 
  in file dir/fgen is presented (not coordinates of generation mesh!).
  generation mesh coordinates are calculated from p1, p2, N (in 3D).
  Generation data will be multuplied on Imult (be default Imult=1)
  */
  scGenerationTable(const char *dir, const char *fgen, 
    const Vector_3 &p1, const Vector_3 &p2, const int *N, valtype Imult_=1);

  /* Generation table [photons/(sec m^3)] is taken from file dir/fgen.
   Generation table has the format (less than 3 coordinates can be used):
   x1 y1 z1 gen
   x1 y1 z2 gen
   x1 y2 z1 gen
   x1 y2 z2 gen
   x2 y1 z1 gen
   x2 y1 z2 gen
   x2 y2 z1 gen
   x2 y2 z2 gen
   arg - which columns in the file correspond to coordinates x,y,z (by default 0,1,2).
   jval which column correspond to the generation rate (by default 3).
   arg_num is number of coordinates (be default 3).
   if arg_num=3, all x,y,z coordinates are used.
   if arg_num=2, coordinates x,y are used, and z is assumed to be 0.
   if arg_num=1, coordinate x isused, and y,z are assumed to be 0.
   generation table is assumed to be shifted (shift) and linearly transformed (bs) 
   relative to the calculated geometry.
   Generation data will be multuplied on Imult (by default Imult=1).
   First column is not read by default (format=TABLE_HEADER). If format=0, then first column will be read
  */
  scGenerationTable(const char *dir, const char *fgen, const iVector_3 &arg=iVector_3(0,1,2), int jval=3, 
    int arg_num=3, const Basis_3 &bs_=Basis_3(Vector_3(1,0,0),Vector_3(0,1,0),Vector_3(0,0,1)), const Vector_3 &shift_=0, 
    valtype Imult_=1, int format=TABLE_HEADER): gen(){
    if(init(dir,fgen,arg,jval,arg_num,bs_,shift_,Imult_,format)<0)
      throw 1;
  }

  int init(const char *dir, const char *fgen, const iVector_3 &arg=iVector_3(0,1,2), int jval=3, 
    int arg_num=3, const Basis_3 &bs_=Basis_3(Vector_3(1,0,0),Vector_3(0,1,0),Vector_3(0,0,1)), const Vector_3 &shift_=0, 
    valtype Imult_=1, int format=TABLE_HEADER);

  ~scGenerationTable(){
    if(gen)delete[]gen;
  }

  valtype operator()(const Vector_3 &pos);
};

// angular averaging of some generation
class scGenerationCylinder: public scGeneration{
  mngptr<scGeneration> gen; // generation to be averaged

  int sym; // longitudinal axis (angular averaging is performed in the plane perpendicular to this axis)
  Vector_3 center; // longitudinal axis passes through this point

  int num; // number of points for angular averaging

public:
  
  scGenerationCylinder(mngarg<scGeneration> gen_, int sym_, const Vector_3 &center_, int num_=64):
  gen(gen_),sym(sym_),center(center_),num(num_){}

  valtype operator()(const Vector_3 &pos);

};

// space averaging (smoothing) of some generation
class scGenerationAverage: public scGeneration{

  mngptr<scGeneration> gen; // generation to be averaged (smoothed)
  valtype box_size; // averaging box size
  int box_num; // number of points used for averaging

public:

  scGenerationAverage(mngarg<scGeneration> gen_, valtype box_size_=0, int box_num_=1):
  gen(gen_),box_size(box_size_),box_num(box_num_){}

  valtype operator()(const Vector_3 &pos) {
    if(box_size==0 || box_num<=1)
      return (*gen)(pos);
    valtype res=0;
    int num=0;
    Vector_3 point;
    int ic[3];
    for(ic[0]=0;ic[0]<box_num;ic[0]++){
      point[0]=pos[0]-box_size/2+box_size*ic[0]/(box_num-1);
      for(ic[1]=0;ic[1]<box_num;ic[1]++){
        point[1]=pos[1]-box_size/2+box_size*ic[1]/(box_num-1);
        for(ic[2]=0;ic[2]<box_num;ic[2]++){
          point[2]=pos[2]-box_size/2+box_size*ic[2]/(box_num-1);
          valtype g=(*gen)(point);
          if(g){
            res+=g;
            num++;
          }
        }
      }
    }
    if(num)
      res/=num;
    return res;
  }

};

class sym_binary_function: public virt_binary_function<Vector_3,Vector_3,valtype>{
  mngptr<virt_unary_function<valtype,valtype> > fun;
public:
  sym_binary_function(virt_unary_function<valtype,valtype> *fun_){
    init(fun_);
  }
  void init(virt_unary_function<valtype,valtype> *fun_){
    fun.reset(fun_,1);
  }
  valtype operator()(Vector_3 x1,Vector_3 x2){
    Vector_3 dif=x2-x1;
    return fun.ptr() ? fun->operator()(dif.norm()) : 0;
  }
};


class Gauss: public virt_unary_function<valtype, valtype> {
  valtype a;      ///<\ru Амплитуда (высота) импульса
  valtype t0;     ///<\ru Положение максимума импульса
  valtype tdecay; ///<\ru Полуширина импульса на полувысоте импульса
  valtype width;  ///<\ru Ширина импульса, на которой он обрезается
public:
  Gauss(valtype sa, valtype st0, valtype stdecay, valtype swidth): a(sa), t0(st0), tdecay(stdecay), width(swidth) {};
  valtype operator() (valtype t) {
    if (fabs(t-t0)<width/2){
      valtype xx=(t-t0)/tdecay;
      return a*exp(-xx*xx);
    }
    else
      return 0;
  }
};



/// generation for photonic recycling algorithm (see future publications)
class scGenerationPhotonicRecycling: public scGeneration{
  mngptr<scGeneration> gen0; // solar cell generation

  // additional generation due to photonic recycling (it changes while applying new voltage)
  mngptr<scGenerationTable> gen;

  // these are parameters used to initialize gen
  string dir;
  string fgen;
  iVector_3 arg;
  int jval;
  int arg_num;
  Basis_3 bs;
  Vector_3 shift;
  valtype Imult;
  int format;

  mngptr<virt_binary_function<Vector_3,Vector_3,valtype> > alpha; // absorption distribution alpha(r1,r2)
  // integration grid
  Vector_3 p1, p2;
  int sz[3];
  Vector_3 dr;
  valtype dv;

  // calculating integral[generation(pos') * alpha(pos,pos') * dV]
  valtype integrate(const Vector_3 &pos, valtype *area=NULL) const{
    valtype val=0;
    valtype val_un=0; // this should be uqual or less than one
    Vector_3 pos2=0;
    for(int i=0;i<sz[0];i++){
      pos2[0]=p1[0]+(i+.5)*dr[0];
      for(int j=0;j<sz[1];j++){
        pos2[1]=p1[1]+(j+.5)*dr[1];
        for(int k=0;k<sz[2];k++){
          pos2[2]=p1[2]+(k+.5)*dr[2];
          valtype a=alpha->operator()(pos,pos2);
          valtype g=gen->operator()(pos2);
          val+=a*g;
          val_un+=a;
        }
      }
    }
    val*=dv;
    val_un*=dv;
    if(*area)
      *area=val_un;
    if(val_un>1)
      throw;
    return val;
  }


public:

  scGenerationPhotonicRecycling(const char *dir_, const char *fgen_, const iVector_3 &arg_=iVector_3(0,1,2), int jval_=3, 
  int arg_num_=3, const Basis_3 &bs_=Basis_3(Vector_3(1,0,0),Vector_3(0,1,0),Vector_3(0,0,1)), const Vector_3 &shift_=0, 
  valtype Imult_=1, int format_=TABLE_HEADER): dir(dir_), fgen(fgen_), arg(arg_), jval(jval_), arg_num(arg_num_),
    bs(bs_), shift(shift_), Imult(Imult_), format(format_), dv(0){
    for(int i=0;i<3;i++)
      sz[i]=0;
    change_voltage(0); // initiate zero voltage
  }
  
  // specify solar generation
  void AddSolarGeneration(mngarg<scGeneration> gen0_){
    gen0.reset(gen0_);
  }

  void AddAbsorptionProfile(virt_binary_function<Vector_3,Vector_3,valtype> *alpha_){
    alpha.reset(alpha_);
  }

  // symmetrized absorption profile is alpha(r,r')=alpha'(r-r')
  void AddSymmetrizedAbsorptionProfile(virt_unary_function<valtype,valtype> *fun){
    alpha.reset(new sym_binary_function(fun));
  }

  void SetGenerationGrid(Vector_3 p1_, Vector_3 p2_, int *sz_){
    p1=p1_, p2=p2_;
    dv=1;
    for(int i=0;i<3;i++){
      sz[i]=sz_[i];
      dr[i]=(p2[i]-p1[i])/sz[i];
      if(p2[i]-p1[i])
        dv*=(p2[i]-p1[i])/sz[i];
    }
  }

  int change_voltage(valtype v){
    char fname[100];
    string fgen2=fgen;
    if(!v){
      int i=fgen2.find("%g"); 
      fgen2.erase(i,2);
      strcpy(fname,fgen2.c_str());
    }
    else
      sprintf(fname,fgen2.c_str(),v);

    int exist=0;     // check if file exists

    string cdir=string(dir);
    correct_directory_name(cdir);

    char dfname[1000];
    strcpy(dfname,cdir.c_str());
    strcat(dfname,fname);
    FILE *f=fopen(dfname,"r");
    if(f){ // file is found
      exist=1;
      // update generation with data in this file
      gen.reset(new scGenerationTable(dir.c_str(),fname,arg,jval,arg_num,bs,shift,Imult,format),1);
      fclose(f);
    }
    return exist;
  }

  valtype operator()(const Vector_3 &pos){
    valtype g0=0; //solar generation
    valtype g1=0; // photonic recycling
    if(gen0.ptr())
      g0=gen0->operator()(pos); // constant solar generation
    if(gen.ptr()){ // photonic recycling term
      if(!alpha.ptr()) //alpha is assumed to be delta function delta(r-r')
        g1=gen->operator()(pos);
      else{
        valtype area; // integrated absorption (without generation)
        g1=integrate(pos,&area); // integration with arbitrary alpha(r,r') profile
        valtype g2=gen->operator()(pos); // comparison with delta function (just for test)
        int test=0;
      }
    }
    return g0+g1;
  }
};


#endif
